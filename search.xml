<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode力扣题解合集]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[101. 对称二叉树题意：给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:题解：因为要求数字也要对称，所以递归的话略嫌麻烦，可以层序遍历二叉树，然后对每一层进行回文数判定 易错点：wa了一发，wa在了【0，1】上，想了好久才明白我把为空的结点当成0，结果二叉树本身就含有为0的结点，后来改为-1就ac了 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; n[1005]; int cnt=0,height=0; void bfs(TreeNode* root,int h) &#123; if(!root) &#123; n[h].push_back(-1);//若结点为空，则算作-1 return; &#125; height=max(height,h); n[h].push_back(root-&gt;val); bfs(root-&gt;left,h+1); bfs(root-&gt;right,h+1); &#125; bool isSymmetric(TreeNode* root) &#123; int flag=1; bfs(root,1); for(int i=1;i&lt;=height;i++) &#123; int len=n[i].size(); for(int j=0,t=len-1;j&lt;=t;j++,t--) &#123; if(n[i][j]!=n[i][t]) &#123; flag=0;break; &#125; &#125; if(flag==0) break; &#125; if(flag==0) return false; return true; &#125;&#125;; 206. 反转链表题意：反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解答：1.迭代法（设置head、first、target三个指针）看了题解，别人画的图，侵删 注意：leetcode的题都有链表为空的情况，需要根据写法好好判断，在这里wa了不少发1234567891011121314151617class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* first; ListNode* target; if(!head||!head-&gt;next) return head; first=head;target=head-&gt;next; while(target) &#123; first-&gt;next=target-&gt;next; target-&gt;next=head; head=target; target=first-&gt;next; &#125; return head; &#125;&#125;; 2.递归法12345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode* tem=reverseList(head-&gt;next); head-&gt;next-&gt;next=head; head-&gt;next=NULL; return tem; &#125;&#125;; 3.重建链表法用数组存储原链表的值，再逆序存回去。12345678910111213141516171819202122class Solution &#123;public: int n[10005]; ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode* tem=head; int cnt=1; while(head) &#123; n[cnt++]=head-&gt;val; head=head-&gt;next; &#125; tem-&gt;val=n[cnt-1]; head=tem; for(int i=cnt-2;i&gt;0;i--) &#123; tem-&gt;next-&gt;val=n[i]; tem=tem-&gt;next; &#125; return head; &#125;&#125;; 这一顿折腾，对链表理解深刻了一丢丢！ struct TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(int x) : val(x),left(NULL),right(NULL) {}}; 建树的两种方法C语言struct TreeNode root=(struct TreeNode )malloc(sizeof(struct TreeNode));memset(root,0,sizeof(sizeof(struct TreeNode))); C++TreeNode* root=new TreeNode(int x); 226. 翻转二叉树题意：翻转一棵二叉树。 示例： 输入： 4 / \ 2 7 / \ / \1 3 6 9输出： 4 / \ 7 2 / \ / \9 6 3 1 123456789101112class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; TreeNode* tem=root-&gt;left;//暂存右子树 root-&gt;left=root-&gt;right;//右子树赋给左子树 root-&gt;right=tem; invertTree(root-&gt;left);//递归下去 invertTree(root-&gt;right); return root; &#125;&#125;; 617. 合并二叉树题意：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7输出:合并后的树: 3 / \ 4 5 / \ \ 5 4 7注意: 合并必须从两个树的根节点开始。 解答：感觉挺简单的，而且磨了十几分钟提交也是对的，但是我看了一哈别人的解答意识到我写的可能是假递归？我的答案：1234567891011121314class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if(!t1&amp;&amp;!t2) return NULL; if(!t2) return t1; if(!t1) return t2; t1-&gt;val+=t2-&gt;val; if(!t1-&gt;left&amp;&amp;t2-&gt;left) &#123; t1-&gt;left=t2-&gt;left;t2-&gt;left=NULL;&#125; if(!t1-&gt;right&amp;&amp;t2-&gt;right) &#123; t1-&gt;right=t2-&gt;right;t2-&gt;right=NULL;&#125; mergeTrees(t1-&gt;left,t2-&gt;left); mergeTrees(t1-&gt;right,t2-&gt;right); return t1; &#125;&#125;; 目前最简短版本： 12345678var mergeTrees = function(t1, t2) &#123; if(t1 &amp;&amp; t2)&#123; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); &#125; return t1 || t2;&#125;; 跟别人一比我的递归写的好奇怪啊，继续摸索www]]></content>
      <categories>
        <category>算法及编程</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode力扣第 148 场周赛]]></title>
    <url>%2F2019%2F08%2F04%2Fleetcode%E5%8A%9B%E6%89%A3%E7%AC%AC-148-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[5148. 二叉树着色游戏题意：给你一个二叉树，第一个人在结点X涂上自己的颜色，第二个人另外一点涂上另一个颜色，之后每个人只能涂自己已经涂过的结点的相邻结点（父结点、子结点），轮流来，谁涂得多谁赢。问能否确保第二个人赢。 解答：就是求出以X结点为分割线的三个部分（左儿子家族，右儿子，父亲那边）的结点数，确保其中一个部分大于剩下的两部分+1，或者直接大于n/2，就可以断掉那条生路，保证赢。12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int getnum(TreeNode* root)//求子树结点数 &#123; if(!root) return 0; else return getnum(root-&gt;left)+getnum(root-&gt;right)+1; &#125; void dfs(TreeNode* root,int x,int &amp;ls,int &amp;rs) &#123; if(!root) return; if(root-&gt;val==x) &#123; ls=getnum(root-&gt;left); rs=getnum(root-&gt;right); &#125; else &#123; dfs(root-&gt;left,x,ls,rs); dfs(root-&gt;right,x,ls,rs); &#125; &#125; bool btreeGameWinningMove(TreeNode* root, int n, int x) &#123; int ls,rs; dfs(root,x,ls,rs); //三种划分，左儿子家族个数，右儿子，祖先那边，保证任意一种多于其他两种的和+1就必然成功 int re=n-ls-rs-1; if(ls&gt;(rs+re+1)||rs&gt;(ls+re+1)||re&gt;(ls+rs+1)) return true; else return false; //return max(max(ls,rs),n-ls-rs-1)&gt;(n&gt;&gt;1); &#125;&#125;; 测试样例：[1,3,null,2,4,null,null,5,6,7]73图示如下，显然3结点的右子树结点个数多于一半，第二个人堵住右儿子即可赢得比赛。]]></content>
      <categories>
        <category>算法及编程</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 552 (Div. 3)]]></title>
    <url>%2F2019%2F04%2F17%2Fcf552div3%2F</url>
    <content type="text"><![CDATA[写在前面就业指导课需要交简历啊，在上面吹了一波经常参加cf、leetcode等竞赛，于是不得不参加几场意思意思啊……大半年没打cf了，瞄了眼分数，掉的惨不忍睹呜呜呜为了这次cf熬到了十二点断网，只看了四题，剩下的估摸着也不会，补题是不可能的，最多C、D两题再看看大佬们的解法，学习思路 A. Restoring Three Numbers题意：给你四个数，a+b，a+c，b+c，a+b+c，（abc都为正数，可以相等）让你找出满足条件的a、b、c的值，排名不分先后 解答：用带我入坑的大佬的话说就是“人尽皆知傻逼题”找出四个数中最大的数，减去其他三个就ok了了123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[6]; int maxn = 0,flag = 0; for(int i = 1;i &lt;= 4;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); if(a[i] &gt; maxn) &#123; maxn = a[i];flag = i; &#125; &#125; int cnt = 0; for(int i = 1;i&lt;=4;i++) &#123; if(i!=flag) &#123; printf(&quot;%d&quot;,maxn-a[i]); cnt++; if(cnt&lt;=2) printf(&quot; &quot;); &#125; &#125; printf(&quot;\n&quot;); return 0;&#125; B. Make Them Equal题意：给定一个序列，让其中的每一个数通过+x，-x，或不变三种方式变成同一个数，求最小的非负数x，不存在输出-1 解决：数列中超过三种数肯定是错的，所以先用set求不同数的个数如果只有一种数，每个数不变就好，答案为0；两种，有两个情况，他们有中位数，直接中间的数减去小的数，没有就只能是两个数的差值；三种，只有等差数列才满足条件1234567891011121314151617181920212223242526272829303132333435363738394041 #include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int main()&#123; int n,tem; int num[5]; scanf(&quot;%d&quot;,&amp;n); int a = 0,b = 0,c = 0; set&lt;int&gt; s; set&lt;int&gt; ::iterator it; for(int i = 1;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;tem); s.insert(tem); &#125; int x = s.size(); if(x&gt;3) printf(&quot;-1\n&quot;); else if(x == 1) printf(&quot;0\n&quot;); else &#123; int i = 1; for(it=s.begin();it!=s.end();it++) &#123; num[i++] = *it; &#125; if(x == 2) &#123; int sum = num[1]+num[2]; if(sum%2==0) printf(&quot;%d\n&quot;,sum/2-num[1]); else printf(&quot;%d\n&quot;,num[2]-num[1]); &#125; else &#123; int sum = num[1]+num[3]; if(sum == num[2]*2) printf(&quot;%d&quot;,num[2]-num[1]); else printf(&quot;-1\n&quot;); &#125; &#125; return 0;&#125; C. Gourmet Cat这一题当时思索了一下，先跳过去写D，然后再重新思考，交题的时候刚好断网，换卡开热点惨兮兮题意：一只猫从星期一到星期天每天固定只吃1 2 3 1 3 2 1类食物，三类食物分别有a、b、c数量，主人想出去旅游，从星期几开始无所谓，问这只贵气的猫最多能撑多久 解答：数据比较大啊……(1≤a,b,c≤7⋅10^8)不能纯暴力。可以看出每周1、2、3类食物消耗的量分别是3、2、2，于是我么你先用a、b、c处以3、2、2，看看哪种食物最不能撑然后分别多留出一周，分三种情况暴力处理从一周每一天开始的情况，求出坚持最大天数才使三类存粮最慢消耗为负数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200005;int main()&#123; int n,a,b,c; int s[8][15]=&#123; &#123;1,2,3,1,3,2,1,1,2,3,1,3,2,1&#125;, &#123;2,3,1,3,2,1,1,2,3,1,3,2,1,1&#125;, &#123;3,1,3,2,1,1,2,3,1,3,2,1,1,2&#125;, &#123;1,3,2,1,1,2,3,1,3,2,1,1,2,3&#125;, &#123;3,2,1,1,2,3,1,3,2,1,1,2,3,1&#125;, &#123;2,1,1,2,3,1,3,2,1,1,2,3,1,3&#125;, &#123;1,1,2,3,1,3,2,1,1,2,3,1,3,2&#125; &#125;; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); int x,y,z; x = a/3; y = b/2; z = c/2; int ans = 0; if(x&lt;=y&amp;&amp;x&lt;=z) &#123; x--; ans+=x*7; a-=3*x;b-=2*x;c-=2*x; int ma=0; for(int i=0;i&lt;7;i++) &#123; int cnt=0; x=a,y=b,z=c; for(int j=0;j&lt;14;j++) &#123; if(s[i][j]==1) x--; else if(s[i][j]==2) y--; else if(s[i][j]==3) z--; if(y&lt;0||x&lt;0||z&lt;0) break; cnt++; &#125; ma=max(ma,cnt); &#125; ans+=ma; &#125; else if(y&lt;x&amp;&amp;y&lt;z) &#123; y--; ans+=y*7; a-=3*y;b-=2*y;c-=2*y; int ma=0; for(int i=0;i&lt;7;i++) &#123; int cnt=0; x=a,y=b,z=c; for(int j=0;j&lt;14;j++) &#123; if(s[i][j]==1) x--; else if(s[i][j]==2) y--; else if(s[i][j]==3) z--; if(y&lt;0||x&lt;0||z&lt;0) break; cnt++; &#125; ma=max(ma,cnt); &#125; ans+=ma; &#125; else &#123; z--; ans+=z*7; a-=3*z;b-=2*z;c-=2*z; int ma=0; for(int i=0;i&lt;7;i++) &#123; int cnt=0; x=a,y=b,z=c; for(int j=0;j&lt;14;j++) &#123; if(s[i][j]==1) x--; else if(s[i][j]==2) y--; else if(s[i][j]==3) z--; if(y&lt;0||x&lt;0||z&lt;0) break; cnt++; &#125; ma=max(ma,cnt); &#125; ans+=ma; &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125; D. Walking Robot题意：一个机器人要从0走到n，它拥有b节普通电池和a节太阳能蓄力电池，每走一步路需要消耗一节电池，这段路上另外有个数组si表示i-1到i处是否有太阳，为1表示有太阳，有阳光的话可以给不在使用的太阳能蓄力电池充电，求小机器人最多能走几步（n封顶） 解答:一遍模拟，精髓就在于一定要先用太阳能电池，其他没啥了12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200005;int main()&#123; int n,a,b,x,y; int s[maxn]; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;a,&amp;b); x = a; y = b; for(int i = 1;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); &#125; int flag = -1; for(int i = 0;i &lt; n; i++) &#123; if(y&lt;b&amp;&amp;x&gt;0&amp;&amp;s[i+1]==1) &#123; y++;x--; &#125; else if(y&gt;0) &#123; y--; &#125; else if(x&gt;0) &#123; x--; &#125; else &#123; flag = i;break; &#125; &#125; if(flag == -1) printf(&quot;%d\n&quot;,n); else printf(&quot;%d\n&quot;,flag); return 0;&#125; 现在该看剧睡觉啦，等之后有空研究大佬们思路的话，再过来补充~~~]]></content>
      <categories>
        <category>算法及编程</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode力扣第 132 场周赛]]></title>
    <url>%2F2019%2F04%2F16%2Fleetcode%E5%8A%9B%E6%89%A3%E7%AC%AC132%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[leetcode第132场周赛……心血来潮突然想试试，然后只对了第一道划水签到题…… 乖乖补题 5024. 除数博弈爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 解答：草稿纸手算各种情况，反正这种简单博弈论的题首先就判断奇偶的情况就对了，然后我又思考了质数和合数的情况 事实证明，只要判断奇偶就可以了1234567class Solution &#123; public: bool divisorGame(int N) &#123; if(N % 2 == 0) return true; else return false; &#125;&#125;; 5030.节点与其祖先之间的最大差值给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先） 废话：这种树形结构看到我就头皮发麻，再加上搜索学的比较差劲，没怎么挣扎就放弃了，结束参考了排名前几大佬的代码，一个dfs就搞定，我真菜啊 解答：思路就是从根节点出发开始搜索，一方面比较当前节点和最大值/最小值的绝对值，一方面更新最大最小值，因为是顺着一条条支路走下去的，所以结果一定是祖先和其后代的差值12345678910111213141516171819202122232425262728 /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:void dfs(TreeNode* root,int x,int y,int &amp;ans)&#123;if(!root) return ;ans = max(ans,abs(x-root-&gt;val));ans = max(ans,abs(y-root-&gt;val));x = max(x,root-&gt;val);y = min(y,root-&gt;val);dfs(root-&gt;left,x,y,ans);dfs(root-&gt;right,x,y,ans);&#125;int maxAncestorDiff(TreeNode* root) &#123;int ans = 0;int x,y;x = y = root-&gt;val;dfs(root,x,y,ans);return ans;&#125;&#125;; 5025. 最长等差数列给定一个整数数组 A，返回 A 中最长等差子序列的长度。 解答：设置一个dp[i][j],表示以i结尾的差值为j的最长等差序列的个数，但要注意，这里不能用二维数组，因为j有可能为负数，所以最省力的做法就是unordered_map啦123456789101112131415161718class Solution &#123;public:int longestArithSeqLength(vector&lt;int&gt;&amp; A) &#123;unordered_map&lt;int,int&gt; dp[2005];int len = A.size();int ans = 2;for(int i = 0; i &lt; len; ++i)&#123;for(int j = i+1; j &lt; len; ++j)&#123;int cha = A[j]-A[i];dp[j][cha]=max(dp[j][cha],dp[i][cha]+1);ans = max(ans,dp[j][cha]+1);&#125;&#125;return ans;&#125;&#125;;]]></content>
      <categories>
        <category>算法及编程</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子列和问题]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[给定K个整数组成的序列，求其中连续子列的最大和，若为负数返回0。 O（n）的做法：12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;int a[maxn];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int ans = 0, tem = 0; for(int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;,&amp;a[i]); tem += a[i]; if(tem &gt; ans) ans = tem; else if(tem &lt; 0) tem = 0; &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125; 思路：如果当前值使得序列总和小于零，那一定跳过该值重新开始序列求和。]]></content>
      <categories>
        <category>算法及编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM数据结构模板大全（持续更新）]]></title>
    <url>%2F2019%2F04%2F09%2FACM%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[整理一波实用的C++或Java模板，也算是帮自己复习一遍~线段树、线段树单点修改区间求和模板1234567891011121314151617181920212223242526272829303132333435363738394041424344const int maxn=1005;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1int sum[maxn&lt;&lt;2],n;void push_up(int rt)&#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void build(int l,int r,int rt)//建树&#123; if(l==r) &#123; scanf(&quot;%d&quot;,&amp;sum[rt]); return ; &#125; int mid=l+r&gt;&gt;1; build(lson); build(mid+1,r,rt&lt;&lt;1|1); push_up(rt);&#125;void upd(int p,int val,int l,int r,int rt)//更新&#123; if(l==r) &#123; sum[rt]+=val; return; &#125; int mid =l+r&gt;&gt;1; if(p&lt;=mid) upd(p,val,lson); else upd(p,val,rson); push_up(rt);&#125;int query(int L,int R,int l,int r,int rt)//查询&#123; if(L&lt;=l&amp;&amp;R&gt;=r) &#123; return sum[rt]; &#125; int mid =l+r&gt;&gt;1; int ret=0; if(L&lt;=mid) ret+=query(L,R,lson); if(R&gt;mid) ret+=query(L,R,rson); return ret;&#125; Kruskal算法并查集求最小生成树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define maxn 25005using namespace std;/*边的定义*/typedef struct edge&#123; int x,y; //边的两个端点编号 int cost; //边权&#125;edge;edge s[maxn];int t,n,f[510];/*边的比较函数*/bool cmp(edge a,edge b)&#123; return a.cost&lt;b.cost;&#125;void init()&#123; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; &#125;&#125;int find(int x)/*并查集查询函数，返回x所在集合的根结点*/&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;void merge(int x,int y)&#123; int fx=find(x); int fy=find(y); f[fx]=fy;&#125;/*Kruskal算法求无向图的最小生成树*/int Kruskal()&#123; sort(s+1,s+1+t,cmp); int ans=0,k=0; for(int i=1;i&lt;t;i++) &#123; if(find(s[i].x)!=find(s[i].y)) &#123; ans=s[i].cost; merge(s[i].x,s[i].y); k++; &#125; if(k==n-1) return ans; &#125;&#125;int main()&#123; int z; scanf(&quot;%d&quot;,&amp;z); while(z--) &#123; scanf(&quot;%d&quot;,&amp;n); int x; init();t=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; scanf(&quot;%d&quot;,&amp;x); if(j&gt;i&amp;&amp;x!=0) &#123; s[t].x=i;s[t].y=j; s[t].cost=x; t++; &#125; &#125; &#125; int res=Kruskal(); printf(&quot;%d\n&quot;,res); &#125;&#125;]]></content>
      <categories>
        <category>算法及编程</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU计算机系统结构期末复习]]></title>
    <url>%2F2019%2F04%2F02%2FXTU%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[-湘潭大学2018-2019学年计算机系统结构期末考试基本上都是原题吧，下面的题目都是老师给的复习资料和我自己从其他试卷上看到的，和部分在考试中出现的题目。认真看完这些，考试及格应该是没啥问题，但是想学精通的话，还要自己努力qaq 一、选择题（每题2分，共20分） 1、ILLIAC Ⅳ阵列处理机中，PE之间所用的互连函数是（ D ）。 A、Cbule0和Cbule1 B、PM2±2 C、Shuffle D、PM2±0和PM2±3 2、某CPU访问存储器与访问I/O端口的指令相同，则存储器与I/O端口( C ) A、它们的地址编码可能重叠 B、它们的地址编码一定重叠 C、它们的地址编码一定互斥 D、寻址它们地址线数通常不同 3、解决软件移植最好的办法就是（ D ）。 A、采用模拟方法 B、采用仿真的方法 C、采用统一标准设计计算机结构 D、采用统一高级语言 4、计算机优化使用的操作码编码方法是（ B ）。 A、BCD码 B、扩展操作码 C、ASCII码 D、哈夫曼编码 5、中断地址是（ A 中断向量是中断服务程序入口地址 ） A、中断返回地址 B、中断服务程序入口地址 C、中断服务程序入口地址表 D、子程序入口地址 6、 IBM 370系统中，中断响应优先级级别最高的中断类型是（ C 紧急的机器检验错误＞程序性错误＞外部事件＞外围设备＞重新启动 ）。 A、程序性中断 B、重新启动中断 C、紧急机器校验中断 D、输入输出中断 7、用N=16的互联网络互联16个处理机，编号为0～15，若网络实现的互联函数为Cube2(Cube0),则从7号处理机联接到的处理机号是（ A ）。 A、2 B、 6 C、3 D、 12 8、下列选项中不是冯诺伊曼型计算机的最根本特征的是( A ) A、指令并行执行 B、以运算器为中心 C、存储器按地址访问 D、数据以二进制编码，并采用二进制运算 9、当浮点数值尾数的基值为8，除尾符之外尾数机器位数为6位时，可表示的规格化最小的正尾数值是（ A 最小正尾数为1/rm ）。 A、0.125 B、0.25 C、0.5 D、1/64 10、与线性流水线最大吞吐率有关的是（ A ）。 A、最慢子过程的执行时间 B、最快子过程的执行时间 C、各个子过程的执行时间 D、最后子过程的执行时间 二、填空题（每题2分，共20分） 1、在浮点数的尾数基值rm 取2，并采用 隐藏位 技术，可以做到表示数范围最大，表示数精度最高，表示效率最好。 2、在同一时间内，多功能流水线中的各个功能段可以按照不同的方式连接，实现同时执行多种功能 是 动态流水线 。 3、基本输入输出方式中程序控制方式称为 状态驱动输入输出方式 。 4、2-4-8扩展编码方法的最短码长是2位，最长码长是8位，最多可编码的码点数为 178 个。 5、假定我们将一执行部件的40%改进后速度提高10倍。改进后被改进部件执行时间占系统总运行时间的50%。则改进后，获得的加速比Sp是 5.5 Sn=T0/Tn 。 6、中断屏蔽不能改变中断 响应 优先次序，但是，它能动态改变中断执行次序。 7、在典型程序中，转移指令占的比例为p=20%，转移成功概率为q=60%，那么对于8段流水线的最大吞吐率下降百分比为 46% D=pq*(k-1)/(1+pq(k-1)) 。 8、一个由50台计算机组成的Cluster系统的指令内部由4个PentiumⅣ 750M，这个系统指令峰值速度为 610^5 MIPS 5044750 。 9、ILP=n的k段超流水处理机执行N条指令相对于单发射流水处理机的加速比为 n ( N+k-1) / (nk+N-1) 。 10、在尾数采用补码、小数表示且p=6，阶码采用移码、整数表示且q=6，尾数基值rm为16，阶码基值re为2的情况下：对于这规格化浮点数，阶数最大值为 63 。 1、k是指令流水线周期数，一台指令并行度为（m,n）超标量超流水处理处理机连续执行N条指令，它们没有资源冲突，没有数据相关和控制相关，对于单发射流水处理机的加速比为 mn(k+N－1) /(mnk+N-M) 。 3、在共享存储器并行处理机中，处理机个数为32个，那么要实现无冲突访问，存储器个数通常取 37。 4、2-4-8扩展编码方法的最短码长是2位，最长码长是8位，最多可编码的码点数为 178 个。 三、判断题（每题1分，共10分） 1、FIFO算法属于堆栈型算法，它反映程序的局部性原理。（ X ） 2、在满足Cache与主存的一致性方面，写回法比写直达法好。（ X ） 3、系统机应用软件应做到向前兼容，力争向下兼容。（ X ） 4、系列机低档性能低，价格低，高档机高性能，价格高，因此在购置计算机时，是购置性能价改比高的中档计算机。（ YES ） 5、紧耦合多处理中，各处处理机运行程序段之间如有先写后读数据相关是不能并行的。（ YES ） 6、系统是否设浮点运算指令，对计算机系统结构是透明的。（ X ） 7、计算机通道每完成一次输入/输出工作，CPU需要两次调用管理程序。（ YES ） 8、系列机不再是发展方向，因为它约束了计算机结构的发展。（ X ） 9、对概率不等事件中用Huffman编码，其编码不唯一，但平均码长是唯一最短的。（ YES ） 10、中断嵌套时，在处理某级中断中的某个中断请求过程中是不能被同级的其他中断请求所中断的。（ YES ） **ILLIAC IV阵列处理机中，采用闭合螺旋网格是8步。（X 闭合螺旋网格是7步，环形网格是8步） **独立请求和定时查询都可以用软件方法动态改变总线分配优先级。 （YES） **流水线机器中处理中断应着眼于解决断点现场如何保存和恢复，而不在于如何缩短断流的时间，去追求流水高吞吐率和高效率。（YES） **某机器尾数用小数，原码表示，它在运算中采用 恒置1 规则恢复隐藏位。（YES，补码的话是加符号位的相反数） 四、简答题（每题5分，共20分） 1、如果外设要求的通道实际流量十分接近或等于通道具有的最大流量时，则可能发生局部的数据丢失问题，我们怎样解决？ 答：增加通道的最大流量； 动态改变设备的优先级 增加缓冲存储器，尤其是优先级比较低的设备 2、解决软件移植最好的办法有哪些？ 答：采用系列机 采用模拟与仿真 统一高级语言（最好） 目标代码并行编译 3、证明在浮点数的字长和表数范围一定时，尾数基值rm 取2或4具有最高的表数精度。 4、假设一条指令的执行过程分为”取指令”、”分析”和”执行”三段，每一段的时间分别为△t、2△t和3△t。在下列各种情况下，分别写出连续执行n条指令所需要的时间表达式。 (1)顺序执行方式。 (2) “取指令”、”分析”和”执行”重叠。 答：（1）6nt （2）(3+3n)t 5、RISC处理机的关键技术有哪四种？(B24) 1.延时转移技术 2.指令取消技术 3.重叠寄存器窗口技术 4.指令流水调整技术 6、多处理机有那些基本特点？发展这种系统的主要目的有哪些？多处理机着重解决那些技术问题？ 答：结构灵活 程序并行 并行任务派生 进程同步 资源分配和进程调度变复杂 目的：利用多处理机并发执行一个作业，使得执行速度比单处理机快 着重解决的技术问题： 硬件结构上多处理机、主存、I/O子系统之间应有高带宽，低价格，灵活无规则互联，尽可能不发生信息传送冲突从并行语言并行算法编译等，最大限度地开发程序并行性大的任务划分成小任务从操作系统上解决并行任务分配、调度和资源分配7、向量的处理方式有哪三种？各有何特点？ 横向处理方式，向量计算是按行的方式从左至右横向进行纵向，按列自上而下纵横处理方式，横向处理和纵向处理相结合的方式8、向量处理机实现链接的条件是什么？(A1) 1.没有向量寄存器冲突和运算部件冲突 2.只有第一条结果送入向量寄存器的那一个周期可以链接 3.先行的两条指令产生运算结果的时间必须相等 4.两条向量的向量长度必须相等 9、提高向量处理机性能的常用技术有那些？ 1.向量链接技术 2.向量循环开采技术 3.向量递归技术 10、列出互连网络中四种（消息）寻径方式？并指出它们各自优缺点? 1.线路交换，实际通信时间短，使用缓冲区少；建立物理通路开销大，占用物理通路的时间很长 2.存储转发，占用物理通路时间短；包缓冲区大，时延大 3.虚拟直通，通信延迟与节点数无关；缓冲大 4.虫蚀寻径，每个结点的缓冲区小，时延低；易被阻塞 11、采用并行处理机的SIMD 计算机主要特点是什么？ 答：适用于高速数值计算，具有比较固定的结构，依靠的并行措施是资源重复，互联网规定了处理单元的连接模式，基本上是一台向量处理专用计算机 12、设计一台计算机应有哪五类基本指令？(B12) 1.数据传送指令 2.运算类指令 3.程序控制指令 4.输入输出指令 5.处理机控制和调试指令 13、在流水线遇到瓶颈流水段应该怎样处理该流水段来提高流水线效率？ 1.将瓶颈部分再细分 2.重复设置瓶颈功能段，增加分配器和收集器 14、在设计一个计算机系统时，确定数据表示的原则主要有哪几个？(B23) 1.缩短程序的运行时间 2.减少CPU与主存储器之间的通信量 3.这种数据表示的通用性和利用率 15、什么是机群系统？ 答：机群系统是利用高速网络将一组高性能工作站或高端PC机连接起来，在并行程序设计以及可视化人机交互集成开发环境下，统一调度，协调工作，实现高效并行处理机的计算机系统 16、机群系统关键技术是什么？ 1.高效的通信系统 2.并行程序设计环境 3.并行程序设计语言 4.负载平衡技术 5.并行程序调整技术 6.可靠性技术 17、什么是并行处理机？ 答：多个处理部件PU按照一定方式互连，在同一个控制部件CU控制下，对各自的数据完成同一条指令规定的操作。从CU看，指令是串行执行的，从PU看，数据是平行处理的。 18、llliac Ⅳ由哪三大部分组成？ 1.专门对付数组运算的处理单元阵列 2.阵列控制器 3.标准的B6700计算机 19、多处理机系统与并行处理机的主要差别是什么？ 答:1.并行处理机的并行性在于指令内部，而多处理机的并行性在于指令外部 2．并行处理机只有一个CU，自然同步，多处理机执行时间可能互不相同 20、中国“天河二号”超级计算机在那些技术方面取得重大突破？ 答： 21、在多处理机系统中,Cache一致性问题由什么引起,主要采用哪两种方法解决?(B13) 答：Cache一致性问题主要由共享可写的数据、进程迁移、I/O 传输等原因产生。目前主要采用监听协议和基于目录的协议，分别适用于不同结构。 22、超标量处理机和超流水线处理机异同点。(B21) 答：超流水线处理机的工作方式与超标量处理机不同，超标量是以增加硬件资源为代价来换取处理机性能，而超流水线处理机是通过部分硬件的充分重叠工作提高处理机性能的。超标量是空间并行性，超流水线是时间并行性 23、什么是CISC、RISC？ 答：把一些原来由软件实现的、常用的功能改用硬件的指令系统来实现，复杂指令系统CISC；RISC精简指令系统 24、请你分析浮点数的尾数基值为2，同号相加或异号相减，是否需要设置警戒位？(B22) 25、请你分析浮点数的尾数基值为2，同号相减或异号相加，阶差大于等于2，需要设置警戒位吗？需要设置几位警戒位?（B14）。 答:需要设置一位警戒位 26、简述流水线技术特点(B11) （1）只有连续提供同类任务才能发挥流水线效率，尽量减少因条件分支造成的“断流”，通过编译技术提供连续的相同类型操作。 （2）每个流水段都要设置一个流水寄存器，增加时间开销：流水线的执行时间加长；增加硬件开销：每段需要增加一个寄存器。 （3）各流水段的时间应尽量相等，流水线处理机的基本时钟周期等于时间最长的流水段的时间长度。 （4）流水线需要有“装入时间”和“排空时间”。 与虚拟存储器的等效访问速度无关的是（ D ） A、访存页地址流 B、页面替换算法 C、主存的容量 D、辅存的容量 六、计算题 某机有16个向量寄存器，其中V0到V5中分别存放向量A、B、C、D、E、F，向量长度均为8，向量各元素均为浮点数，处理部件采用二个单功能流水线，加法功能部件时间为2拍，乘法功能部件时间为3拍。采用类似CRAY1的链接技术，先计算（A+B）C，在流水线不停流的情况下，接着计算（D+E）F。(1）设寄存器入、出各需1拍，那么此链接流水线的流过时间需要多少拍（4分）？（2）假设每拍时间为50ns，完成这些计算并把结果存进相应寄存器，此处理部件的实际吞吐率为多少MLOPS（4分）? (1+2+1)+(1+3+1)=9拍 (282) /( ( 9+ (82-1) )0.05=26.7MFLOPS 四条指令，总共32个浮点操作 中断问题 有5个中断源，其中断优先级1级最高，5级最低，正常情况下的中断屏蔽码和 改变后的中断屏蔽码如下表所示，每个中断源的有5位中断屏蔽码，其中“1” 表示该中断源被屏蔽，“0”表示该中断源开放。 假设处理机从响应中断源的中断服务请求开始，到运行中断服务程序中第一次开中断所用时间为1个单位时间，运行中断服务程序的其它部分所使用的时间为4个单位时间，那么在执行主程序时，有D3、D4和D5同时发出中断服务请求，过了3个单位时间，又有中断源D1和D2同时发出中断服务请求，如果使用改变后中断屏蔽码，请画出处理机响应中断源的中断服务请求和实际运行中断服务程序过程示意图。 注意要点: 1.画图的时候一定要记得最后返回主程序然后接着向下进行 2.处理响应中断请求的顺序是，在没有被屏蔽的中断源中，找出优先级最高的一个中断源先响应。（我们班两个学霸因为这个问题错了一晚上，详细解答在计算机系统结构（清华大学出版社）这本书的230页） 线性流水线和非线性流水线问题看懂了其实挺简单的，这里懒得找资料了，大家自己看书吧，有心去做一定可以看懂der！ 祝看到这篇的大嘎期末有个好成绩~]]></content>
      <categories>
        <category>课程学习</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab的安装及破译]]></title>
    <url>%2F2019%2F04%2F01%2FMatlab%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[写在前面本着好好学习的原则，这学期的选修课没有选什么“人工智能”等一听起来方向很大就很水的选修课，挑战自我选修了数字图像处理，勇气可嘉。目前还在摸索中，没学到什么特别有用的东西，先把必备软件matlab装上再说。 第一步（最重要的一步）： 放上下载链接！！链接:https://pan.baidu.com/s/1nxw14nOfQeMiYYLmkNO-cw提取码:dw1h（版本为2017a，文件内容过大，所以分成了两部分，强烈建议下载之后新建一个文件夹，将两部分解压至一处） 第二步：点击setup.exe，等待稍许，出现如下界面，选择使用文件安装密钥 第三步：输入文件安装密钥，可在破译文件中找到 第四步：选择合适的位置安装位置，文件较大，不建议使用系统默认盘 第五步：勾选全部产品，等待安装 很久很久之后…… 第六步：（如果没有将将部分解压到同一个文件夹，这个过程会暂停，此时仍需要把part2中的两个文件复制到1所在文件夹）安装完成后，点击bin目录下的matlab.exe，进行软件激活 第七步：选择“在不使用Internet的情况下激活”，与此同时，将破译文件下的license_standalone.lic 复制到 \MATLAB\R2017a\licenses\，netapi32.dll 复制到 \MATLAB\R2017a\bin\win64\ 第八步：输入许可证文件的完整路径，即为刚刚复制的license_standalone.lic 大功告成~耶]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个有序链表的合并]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[两个有序链表的合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read() &#123; int n; scanf(&quot;%d&quot;,&amp;n); List L = (List)malloc(sizeof(PtrToNode)); L-&gt;Next = NULL; List r = L; for(int i=1;i&lt;=n;i++) &#123; List tem = (List)malloc(sizeof(Node)); scanf(&quot;%d&quot;,&amp;(tem-&gt;Data)); r-&gt;Next = tem; r = tem; &#125; r-&gt;Next = NULL; return L;&#125;void Print( List L )//空表输出NULL&#123; if(!L-&gt;Next) printf(&quot;NULL\n&quot;); else &#123; while(L-&gt;Next) &#123; printf(&quot;%d &quot;,L-&gt;Next-&gt;Data); L = L-&gt;Next; &#125; printf(&quot;\n&quot;); &#125;&#125;List Merge( List L1, List L2 )&#123; List L = (List)malloc(sizeof(PtrToNode)); List pa = L1-&gt;Next; List pb = L2-&gt;Next; List pc = L; while(pa &amp;&amp; pb) &#123; if(pa-&gt;Data &lt;= pb-&gt;Data) &#123; pc-&gt;Next = pa; pa = pa-&gt;Next; &#125; else &#123; pc-&gt;Next = pb; pb = pb-&gt;Next; &#125; pc = pc-&gt;Next; &#125; while(pa) &#123; pc-&gt;Next = pa; pc = pc-&gt;Next; pa = pa-&gt;Next; &#125; while(pb) &#123; pc-&gt;Next = pb; pc = pc-&gt;Next; pb = pb-&gt;Next; &#125; L1-&gt;Next = NULL; L2-&gt;Next = NULL; return L;&#125;int main()&#123; List L1, L2, L; L1 = Read(); L2 = Read(); L = Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;]]></content>
      <categories>
        <category>算法及编程</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
